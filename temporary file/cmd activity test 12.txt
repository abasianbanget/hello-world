Error loading configuration: [Errno 2] No such file or directory: 'config/config.yaml'
✓ Konfigurasi loaded: {'project_settings': {'default_crs': 'EPSG:4326'}}
Mencoba membaca file: D:\PROJECT\Simulasi-Kasus-Lahan\data\raw\sample_land_data.shp
Successfully read shapefile: D:\PROJECT\Simulasi-Kasus-Lahan\data\raw\sample_land_data.shp
✓ Data loaded dengan 100 records
Cleaned data: 100 records
✓ Data berhasil dibersihkan
Stored 'gdf_clean' (GeoDataFrame)


---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[4], line 16
     14     # Interactive map
     15     fig = create_interactive_map(gdf_clean, 'value', 'Land Value Distribution')
---> 16     fig.show()
     18 except NameError:
     19     print("Variabel gdf_clean tidak ditemukan. Pastikan sel sebelumnya berhasil dijalankan.")

File ~\AppData\Local\Programs\Python\Python313\Lib\site-packages\plotly\basedatatypes.py:3420, in BaseFigure.show(self, *args, **kwargs)
   3387 """
   3388 Show a figure using either the default renderer(s) or the renderer(s)
   3389 specified by the renderer argument
   (...)   3416 None
   3417 """
   3418 import plotly.io as pio
-> 3420 return pio.show(self, *args, **kwargs)

File ~\AppData\Local\Programs\Python\Python313\Lib\site-packages\plotly\io\_renderers.py:407, in show(fig, renderer, validate, **kwargs)
    404 fig_dict = validate_coerce_fig_to_dict(fig, validate)
    406 # Mimetype renderers
--> 407 bundle = renderers._build_mime_bundle(fig_dict, renderers_string=renderer, **kwargs)
    408 if bundle:
    409     if not ipython_display:

File ~\AppData\Local\Programs\Python\Python313\Lib\site-packages\plotly\io\_renderers.py:315, in RenderersConfig._build_mime_bundle(self, fig_dict, renderers_string, **kwargs)
    312             if hasattr(renderer, k):
    313                 setattr(renderer, k, v)
--> 315         bundle.update(renderer.to_mimebundle(fig_dict))
    317 return bundle

File ~\AppData\Local\Programs\Python\Python313\Lib\site-packages\plotly\io\_base_renderers.py:92, in PlotlyRenderer.to_mimebundle(self, fig_dict)
     88 if config:
     89     fig_dict["config"] = config
     91 json_compatible_fig_dict = json.loads(
---> 92     to_json(fig_dict, validate=False, remove_uids=False)
     93 )
     95 return {"application/vnd.plotly.v1+json": json_compatible_fig_dict}

File ~\AppData\Local\Programs\Python\Python313\Lib\site-packages\plotly\io\_json.py:222, in to_json(fig, validate, pretty, remove_uids, engine)
    219     for trace in fig_dict.get("data", []):
    220         trace.pop("uid", None)
--> 222 return to_json_plotly(fig_dict, pretty=pretty, engine=engine)

File ~\AppData\Local\Programs\Python\Python313\Lib\site-packages\plotly\io\_json.py:143, in to_json_plotly(plotly_object, pretty, engine)
    138         opts["separators"] = (",", ":")
    140     from _plotly_utils.utils import PlotlyJSONEncoder
    142     return _safe(
--> 143         json.dumps(plotly_object, cls=PlotlyJSONEncoder, **opts), _swap_json
    144     )
    145 elif engine == "orjson":
    146     JsonConfig.validate_orjson()

File ~\AppData\Local\Programs\Python\Python313\Lib\json\__init__.py:238, in dumps(obj, skipkeys, ensure_ascii, check_circular, allow_nan, cls, indent, separators, default, sort_keys, **kw)
    232 if cls is None:
    233     cls = JSONEncoder
    234 return cls(
    235     skipkeys=skipkeys, ensure_ascii=ensure_ascii,
    236     check_circular=check_circular, allow_nan=allow_nan, indent=indent,
    237     separators=separators, default=default, sort_keys=sort_keys,
--> 238     **kw).encode(obj)

File ~\AppData\Local\Programs\Python\Python313\Lib\site-packages\_plotly_utils\utils.py:162, in PlotlyJSONEncoder.encode(self, o)
    155 """
    156 Load and then dump the result using parse_constant kwarg
    157 
    158 Note that setting invalid separators will cause a failure at this step.
    159 
    160 """
    161 # this will raise errors in a normal-expected way
--> 162 encoded_o = super(PlotlyJSONEncoder, self).encode(o)
    163 # Brute force guessing whether NaN or Infinity values are in the string
    164 # We catch false positive cases (e.g. strings such as titles, labels etc.)
    165 # but this is ok since the intention is to skip the decoding / reencoding
    166 # step when it's completely safe
    168 if not ("NaN" in encoded_o or "Infinity" in encoded_o):

File ~\AppData\Local\Programs\Python\Python313\Lib\json\encoder.py:200, in JSONEncoder.encode(self, o)
    196         return encode_basestring(o)
    197 # This doesn't pass the iterator directly to ''.join() because the
    198 # exceptions aren't as detailed.  The list call should be roughly
    199 # equivalent to the PySequence_Fast that ''.join() would do.
--> 200 chunks = self.iterencode(o, _one_shot=True)
    201 if not isinstance(chunks, (list, tuple)):
    202     chunks = list(chunks)

File ~\AppData\Local\Programs\Python\Python313\Lib\json\encoder.py:261, in JSONEncoder.iterencode(self, o, _one_shot)
    256 else:
    257     _iterencode = _make_iterencode(
    258         markers, self.default, _encoder, indent, floatstr,
    259         self.key_separator, self.item_separator, self.sort_keys,
    260         self.skipkeys, _one_shot)
--> 261 return _iterencode(o, 0)

File ~\AppData\Local\Programs\Python\Python313\Lib\site-packages\_plotly_utils\utils.py:238, in PlotlyJSONEncoder.default(self, obj)
    236     except NotEncodable:
    237         pass
--> 238 return _json.JSONEncoder.default(self, obj)

File ~\AppData\Local\Programs\Python\Python313\Lib\json\encoder.py:180, in JSONEncoder.default(self, o)
    161 def default(self, o):
    162     """Implement this method in a subclass such that it returns
    163     a serializable object for ``o``, or calls the base implementation
    164     (to raise a ``TypeError``).
   (...)    178 
    179     """
--> 180     raise TypeError(f'Object of type {o.__class__.__name__} '
    181                     f'is not JSON serializable')

TypeError: Object of type Point is not JSON serializable




